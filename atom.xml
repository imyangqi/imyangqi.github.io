<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chi&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-02T14:32:03.756Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨琦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的std::function/Lambda表达式/std::bind用法总结</title>
    <link href="http://example.com/2021/04/28/cpp_std_function/"/>
    <id>http://example.com/2021/04/28/cpp_std_function/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-02T14:32:03.756Z</updated>
    
    <content type="html"><![CDATA[<p>关于标准库中的<code>std::function</code>类模板，在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>官方给出的解释是</p><blockquote><p>Class template <code>std::function</code> is a general-purpose polymorphic function wrapper. Instances of <code>std::function</code> can store, copy, and invoke any <code>CopyConstructible</code> <code>Callable</code> target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.</p></blockquote><a id="more"></a><p>翻译成中文的意思是：类模板<code>std::function</code>是一种通用的多态函数封装，<code>std::function</code>的实例可以对任何<code>CopyConstructible Callable</code><strong>目标</strong>进行存储、复制和调用操作，这些<strong>目标</strong>可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。<code>std::function</code>对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。</p><p>比较通俗的理解就是，通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的<code>std::function</code>对象，让我们不需要再纠结那么多的可调用实体。</p><h2 id="直接对函数的封装"><a href="#直接对函数的封装" class="headerlink" title="直接对函数的封装"></a>直接对函数的封装</h2><p>现在定义一个实现加法的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其封装为一个function类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = add;</span><br></pre></td></tr></table></figure><p>现在就我们可以调用<code>f_add</code>实体对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_add(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 结果将返回9</span></span><br></pre></td></tr></table></figure><h2 id="对函数类-结构体的封装"><a href="#对函数类-结构体的封装" class="headerlink" title="对函数类/结构体的封装"></a>对函数类/结构体的封装</h2><p>我们定义一个除法的结构体或者类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_div</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a / b; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其封装为一个function对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_div = my_div();</span><br></pre></td></tr></table></figure><p>同样的，调用形式和上面的<code>f_add</code>一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_div(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 执行完result结果为3</span></span><br></pre></td></tr></table></figure><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用<code>std::function</code>实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculator</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面已经定义的<code>f_add</code>对象作为参数传入<code>calculator()</code>函数中，在内部进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = calculator(<span class="number">4</span>, <span class="number">5</span>, f_add);</span><br></pre></td></tr></table></figure><p>这样我们就实现了函数的回调。</p><h2 id="封装Lambda表达式"><a href="#封装Lambda表达式" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。</p><p>Lambda表达式的完整声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p> 各项具体含义如下 </p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了返回值类型，编译器可以自动推断。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了参数列表，类似普通函数中的无参函数。</span></span><br><span class="line">[capture <span class="built_in">list</span>] &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>让我们来看个例子，现在假设我们有一个无序的<code>vector</code>变量，我们想用C++标准库中的<code>sort</code>函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>sort</code>函数，旧式的做法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(), cmp);<span class="comment">// myvec是一个int类型的无序变量</span></span><br></pre></td></tr></table></figure><p>现在可以方便地利用Lambda表达式来简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span> &#123;<span class="keyword">return</span> a &lt; b;&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[x, y…]</td><td>默认以值的形式捕获指定的多个外部变量（用逗号分隔）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><p>如果我们需要修改捕获变量，这时需要利用<code>mutable</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; ++a; &#125;; <span class="comment">// 执行完后a=101</span></span><br></pre></td></tr></table></figure><h3 id="封装Lambda表达式-1"><a href="#封装Lambda表达式-1" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h3><p>现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_mul = [](<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><h2 id="std-bind函数"><a href="#std-bind函数" class="headerlink" title="std::bind函数"></a>std::bind函数</h2><p>定义：</p><blockquote><p> The function template <code>bind</code> generates a forwarding call wrapper for <code>f</code>. Calling this wrapper is equivalent to invoking <code>f</code> with some of its arguments bound to <code>args</code>. </p></blockquote><p>翻译：</p><p>函数模板<code>bind</code>会对函数模板<code>f</code>生成一个前向调用封装，调用此封装相当于调用<code>f</code>，其某些参数绑定到<code>args</code>。</p><p>解释：</p><p> 函数绑定bind函数用于把某种形式的参数列表与已知的函数进行绑定，形成新的函数。  这种更改已有函数调用模式的做法，就叫函数绑定。需要指出：bind就是函数适配器。 </p><p> 问题：什么是适配器？<br>适配器是一种机制，把已有的东西改吧改吧、限制限制，从而让它适应新的逻辑。需要指出，容器、迭代器和函数都有适配器。<br>bind就是一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。 </p><p> bind使用的一般形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newfun = bind(fun, arg_list);</span><br></pre></td></tr></table></figure><p> 其中fun是一函数，arg_list是用逗号隔开的参数列表。调用newfun()，newfun会调用fun(arg_list); </p><p> bind的常见用法一 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> num)&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; num)  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;  </span><br><span class="line">    <span class="comment">//_1，_2 是占位符  </span></span><br><span class="line">    <span class="keyword">auto</span> fun1 = bind(fun, _1, _2, <span class="number">5</span>);  </span><br><span class="line">    <span class="comment">//等价于调用fun(array, sizeof(array) / sizeof(*array), 5);  </span></span><br><span class="line">    fun1(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(*<span class="built_in">array</span>));  </span><br><span class="line">    <span class="built_in">cin</span>.get();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在本例中，fun()的调用需要传递三个参数，而用bind()进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是bind最常见的用法。</p><p>2._1，_2是占位符，定义于命名空间placeholders中。_1是newfun的第一个参数，_2是newfun的第二个参数，以此类推。</p><p> bind的常见用法二 </p><p> bind的另一个常见的用法是更改参数的调用顺序。如 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> newfun = bind(fun, _2, _1);</span><br></pre></td></tr></table></figure><p> 调用newfun(1, 2);相当于调用fun(2, 1); </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于标准库中的&lt;code&gt;std::function&lt;/code&gt;类模板，在&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/function&quot;&gt;cppreference&lt;/a&gt;官方给出的解释是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class template &lt;code&gt;std::function&lt;/code&gt; is a general-purpose polymorphic function wrapper. Instances of &lt;code&gt;std::function&lt;/code&gt; can store, copy, and invoke any &lt;code&gt;CopyConstructible&lt;/code&gt; &lt;code&gt;Callable&lt;/code&gt; target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式（C++语言）</title>
    <link href="http://example.com/2021/03/03/design_pattern_cpp/"/>
    <id>http://example.com/2021/03/03/design_pattern_cpp/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2021-03-10T02:04:01.881Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。<a id="more"></a></p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>想象一下这样的场景：客户要求用C++面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，并且得到结果。</p><h2 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h2><p>首先考虑一个计算器，展示给用户看到的界面，只有数字和一些运算符，用户操作通常是不同数字和操作符的组合，将其称之为界面逻辑；在程序进行具体计算的过程中，分为多种情况考虑，实现运算的过程称之为业务逻辑。程序设计的原则之一是将业务逻辑与界面逻辑分开，让他们之间的耦合度降低。</p><h2 id="让程序松耦合"><a href="#让程序松耦合" class="headerlink" title="让程序松耦合"></a>让程序松耦合</h2><p>设计程序要尽量做到松耦合，在本案例中应该把加减乘除等运算分离，修改其中一个不会影响到其他的操作符，增加运算算法也不会影响其他代码。首先，是设计一个运算类，它有两个<code>Number</code>属性，主要用于计算前后数，然后有一个虚方法<code>get_result()</code>，用于获得结果。具体的加减乘除写出运算类的子类，然后继承它，重写<code>get_result()</code>方法，这样的话，如果修改任意一个算法，就不需要提供其他算法的代码。</p><p>运算类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Operation() :numA_(<span class="number">0</span>), numB_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Operation() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_numA</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numA_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_numB</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numB_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numA</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; numA_ = a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numB</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123; numB_ = b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> numA_;</span><br><span class="line"><span class="keyword">double</span> numB_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationAdd() &#123;&#125;</span><br><span class="line">~OperationAdd() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() + get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>减法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationSub() &#123;&#125;</span><br><span class="line">~OperationSub() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() - get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>乘法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationMul() &#123;&#125;</span><br><span class="line">~OperationMul() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() * get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationDiv() &#123;&#125;</span><br><span class="line">~OperationDiv() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get_numB() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;Error, divisor cannot be 0.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> get_numA() / get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>现在的问题是如何去实例化对象，考虑用一个单独的类来做这个创造实例的过程，将这个类称之为工厂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation* <span class="title">CreatOperation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; op)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationAdd;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationSub;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationMul;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationDiv;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;Not find operation!&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式实现了计算器的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">OperationFactory factory;</span><br><span class="line">Operation* op = factory.CreatOperation(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">op-&gt;set_numA(<span class="number">5</span>);</span><br><span class="line">op-&gt;set_numB(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">double</span> res = op-&gt;get_result();</span><br><span class="line"><span class="keyword">delete</span> op;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;res is &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p> <strong>工厂方法模式</strong>是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 <code>卡车</code>的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。</p><p> 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 <code>卡车</code>类相关。 在程序中添加 <code>轮船</code>类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 </p><p>最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p> 工厂方法模式建议使用特殊的<em>工厂</em>方法代替对于对象构造函数的直接调用 （即使用 <code>new</code>运算符）。 不用担心， 对象仍将通过 <code>new</code>运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p><p> <img src="https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution1.png" alt="创建者类结构"> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。</summary>
    
    
    
    <category term="编程技巧" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>电磁场数值计算中常用到的一些常数</title>
    <link href="http://example.com/2021/02/18/constants_in_EM/"/>
    <id>http://example.com/2021/02/18/constants_in_EM/</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2021-02-18T11:14:59.594Z</updated>
    
    <content type="html"><![CDATA[<p>在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PI &#x3D; 3.141592653589793;</span><br><span class="line">EPS_0 &#x3D; 8.8541878128e-12;</span><br><span class="line">MU_0 &#x3D; 1.25663706212e-6;</span><br><span class="line">C_0 &#x3D; 299792458;</span><br><span class="line">Z_0 &#x3D; 376.730313668;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为&lt;/p&gt;</summary>
    
    
    
    <category term="数值计算" scheme="http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="电磁场" scheme="http://example.com/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    
    <category term="常数" scheme="http://example.com/tags/%E5%B8%B8%E6%95%B0/"/>
    
  </entry>
  
</feed>
