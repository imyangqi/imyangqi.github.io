<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>琦</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-05T14:24:38.929Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨琦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《少年维特的烦恼》读书笔记</title>
    <link href="http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/"/>
    <id>http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-05-05T14:24:38.929Z</updated>
    
    <content type="html"><![CDATA[<p>五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=316000&auto=1&height=66"></iframe><p>故事中维特为了逃避世事的纷扰，只身来到瓦尔海姆。在一次去乡村舞会的路上，他结识了天使般美丽纯洁的少女夏绿蒂，并对她一见倾心，陷入爱河。这时的绿蒂已经和一个名叫阿尔伯特的人订了婚，阿尔伯特为人正直、诚实、可靠，就连绿蒂也认为：阿尔伯特的“稳重可靠仿佛天生可以作为一种基础，好让一个贤淑的女子在上面建立幸福的生活”。面对看起来如此般配的一对人，维特对绿蒂的爱情烈火并没有就此熄灭，而是越来越旺，维特几乎不能自己。一面是自己深爱的女子，一面是对自己友善的阿尔伯特——她的未婚夫，在三个人的爱情角逐中，维特经过矛盾和痛苦挣扎后不得不忍痛退出，去了一家很远的公使馆担任书记官，然而这里的生活并不如意，他常常郁郁寡欢，彷徨苦闷。最后他又回到了绿蒂身边，这时的绿蒂已经和阿尔伯特结婚，婚后的生活并不愉快。失去维特后，绿蒂的内心空虚寂寥，和维特的久别重逢，使他们再一次陷入爱情的深潭，不可自拔。维特对绿蒂的爱之深切与不能得到绿蒂的矛盾，又使他陷入绝望的境地，极度痛苦的维特最后举枪自杀。</p><p>对于维特最后的选择令我感到心痛，但又理解他的选择。美剧《无耻之徒》里面有一句台词：</p><blockquote><p>Love is not supposed to be cute, love is raw and destructive.<br>爱从来都不是什么可爱的东西，爱是生猛而具有毁灭性的。</p></blockquote><p>维特曾是那么地热爱着自然：</p><blockquote><p>每当我周围的可爱峡谷霞气蒸腾，杲杲的太阳悬挂在林梢，将它的光芒这儿那儿地偷射进幽暗密林的圣地中来时，我便躺卧在飞泉侧畔的茂草里，紧贴地面观察那千百种小草，感觉到叶茎间有个扰攘的小小世界——这数不尽也说不清的形形色色的小虫子、小蛾子——离我的心更近了，于是我感受到按自身模样创造我们的全能的上帝存在，感受到将我们托付于永痕欢乐海洋之中的博爱天父的嘘息。——五月十日</p></blockquote><p>和那么地喜欢着孩子们：</p><blockquote><p>是的，威廉，在这个世界上离我的心最近的是孩子们。每当我从旁边观察他们，从细小的事情中发现他们有朝一日所需要的种种品德与才能的萌芽，从他们今日的固执任性中看出将来的坚毅与刚强，从今日的顽皮放肆中看出将来的幽默乐观以及轻松愉快地应付人世危难的本领，每当我发现这一切还丝毫未经败坏，完整无损，我便一次一次地，反反复复地，吟味人类的导师[1]这句金言。——六月二十九日</p><p>注释：[1]指耶稣。事见《圣经·新约·马太福音》第十八章：耶稣对门徒说：”你们若不回转，变成小孩子的样子，断不得进天国。“</p></blockquote><p>每当我在书中读到维特在自然界中感受到美妙之处，以及和孩子们相处时的快乐，便会联想到自己也是那么地喜欢着大自然和孩子们，很多次走在家乡的田野里，小河边，独自寻觅着路边的野花，静静地聆听潺潺的水流声，和孩子们一起分享食物，教他们使用电脑，给他们布置玩耍的场地，从他们的热情和善良中感受到这个世界的可爱。</p><p>歌德完成这部作品前后只花了四周的时间，之所以能如此高效是因为这部作品中的大部分内容都来自歌德自身的经历。1772年5月，歌德遵循父命到威茨拉尔的帝国高等法院实习。威茨拉尔是座空气陈腐得令人窒息的小城，帝国法院更以办事拖沓而恶名远播。歌德因此把实习的事情抛到脑后，终日悠游于景色宜人的乡间，在那儿研读荷马、品达等人的作品，做他感兴趣的事情。6月9日，在一次乡村舞会上，他结识了天真美丽的少女夏绿蒂·布甫，对她产生了热烈的爱慕。但夏绿蒂已经订婚。尽管她的未婚夫科斯特纳和夏绿蒂一家对歌德都十分友善，但他仍因失恋而感到痛苦，终于在9月11日不辞而别，回到法兰克福。</p><p>回到故乡以后，歌德久久未能克服心头的苦闷，以致产生了自杀的念头。谁料差不多就在这个时候，另一个人却把他几经尝试而放弃的事情完成了，一个他认识的叫耶鲁撒冷的青年自杀了。出事地点也正好在威茨拉尔，歌德在散步时还常常与他相遇。而且自杀的主要原因也同为恋慕他人之妻遭到拒斥。这种种情况，不能不令歌德联想到自身的遭遇，对同病相怜的耶鲁撒冷的不幸感到切肤之痛。</p><p>再后来，1774年初，女作家索菲的女儿玛克西米莲娜嫁给了一个名叫勃伦塔诺的富商，移居到了法兰克福。前年，歌德从威茨拉尔返回故乡时，曾顺便访问她家，对她颇有好感。如今重逢，两人都甚为欣喜。可惜这幸福很快变成了新的痛苦源泉，勃伦塔诺比玛克西米莲娜大二十岁，已经时有五个孩子的鳏夫，除去做生意赚钱别无所长，性情急躁而好嫉妒，很快对两个年轻人的交往产生疑忌，以致和歌德产生激烈冲突。这新的痛苦狠狠触动了歌德心灵中旧有的创伤，使他感到更加痛苦。为了彻底医治好自己的伤痛，歌德便愤而提笔，开始了维特的写作。</p><p>年轻的歌德完全进入了创作的狂热和忘我地境地，就像个梦游者似的，在几乎是无意识的状态下写成了这本小册子，以致当他最后拿起手稿来进行修改润饰时，自己也感到十分惊讶。维特一书之所以能如此情真意切，感人肺腑，这都是因为歌德的亲身感受。</p><p>在信息发达的现代社会，经常能看见新闻有人因为各种原因而结束自己的生命，有时候很难去体会当事者要经历多大的痛苦，才会选择直面死亡，以死亡来结束掉这一切。我知道，这种决定并不是一瞬间完成的，而是从出生到当下的一种经历的积分式结果。我不会也没有权力去指责他人的决定，但我仍会感到惋惜，或许只要再等一等，就能体会到这个世界的一点点美好之处，而放弃结束生命的念头。</p><p>生命的意义是什么？我时常思考这个问题，但每个阶段得到的答案都不尽相同。现在的我觉得生命的意义在于爱，这种爱是对世间万物的爱，对他人的爱。一个人如果只考虑自身的利益，会很容易让自己陷入到一种狭隘的境地，无法去体会世界的美好和可爱之处。我们要去爱他人，去帮助他人，在爱人的过程中感受到被爱，从而建立人与人之间的羁绊。维系着我们生活下去的，正是这一份一份的羁绊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="少年维特的烦恼" scheme="http://example.com/tags/%E5%B0%91%E5%B9%B4%E7%BB%B4%E7%89%B9%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::bind用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_bind/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_bind/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:48:59.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>std::bind</code>包含在标准库头文件<code>#include&lt;functional&gt;</code>中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。<a id="more"></a></p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p> <code>std::bind</code>使用的一般形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, arg_list);</span><br></pre></td></tr></table></figure><p> 其中<code>fun</code>是一个函数，<code>arg_list</code>是用逗号隔开的参数列表。调用<code>new_fun()</code>相当于调用<code>fun(arg_list)</code>。 </p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="用法一：改变参数的个数"><a href="#用法一：改变参数的个数" class="headerlink" title="用法一：改变参数的个数"></a>用法一：改变参数的个数</h3><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders; </span><br></pre></td></tr></table></figure><p>现在定义一个函数，接收一个数组<code>array</code>，数组长度<code>n</code>和某个数<code>num</code>，它将实现打印数组中大于<code>num</code>的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> num)&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; num)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>利用<code>std::bind</code>函数将原来函数调用所需要的参数固定为2个，实现过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _1, _2, <span class="number">5</span>); <span class="comment">//_1，_2是占位符，固定num=5 </span></span><br><span class="line">new_fun(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(*<span class="built_in">array</span>)); <span class="comment">// 调用只需要2个参数了</span></span><br></pre></td></tr></table></figure><p>上面代码中_1，_2是占位符，定义于命名空间<code>placeholders</code>中，_1是n<code>new_fun</code>的第一个参数，_2是<code>new_fun</code>的第二个参数，以此类推。在本例中，<code>fun()</code>的调用需要传递三个参数，而用<code>bind()</code>进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是<code>bind</code>最常见的用法。</p><h3 id="用法二：更改参数的顺序"><a href="#用法二：更改参数的顺序" class="headerlink" title="用法二：更改参数的顺序"></a>用法二：更改参数的顺序</h3><p> <code>bind</code>的另一个常见的用法是更改参数的调用顺序，如 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _2, _1);</span><br></pre></td></tr></table></figure><p> 此时，调用<code>new_fun(1, 2)</code>相当于调用<code>fun(2, 1)</code>。 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::bind&lt;/code&gt;包含在标准库头文件&lt;code&gt;#include&amp;lt;functional&amp;gt;&lt;/code&gt;中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="std::bind" scheme="http://example.com/tags/std-bind/"/>
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::function用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_function/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_function/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:49:04.996Z</updated>
    
    <content type="html"><![CDATA[<p>关于标准库中的<code>std::function</code>类模板，在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>官方给出的解释是</p><blockquote><p>Class template <code>std::function</code> is a general-purpose polymorphic function wrapper. Instances of <code>std::function</code> can store, copy, and invoke any <code>CopyConstructible</code> <code>Callable</code> target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.</p></blockquote><a id="more"></a><p>中文的意思是：类模板<code>std::function</code>是一种通用的多态函数封装，<code>std::function</code>的实例可以对任何<code>CopyConstructible Callable</code><strong>目标</strong>进行存储、复制和调用操作，这些<strong>目标</strong>可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。<code>std::function</code>对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。</p><p>比较通俗的理解就是，通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的<code>std::function</code>对象，让我们不需要再纠结那么多的可调用实体。</p><h2 id="对函数的封装"><a href="#对函数的封装" class="headerlink" title="对函数的封装"></a>对函数的封装</h2><p>定义一个实现加法的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将其封装为一个function类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = add;</span><br></pre></td></tr></table></figure><p>用下面的方式对<code>f_add</code>实体对象进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_add(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 结果将返回9</span></span><br></pre></td></tr></table></figure><h2 id="对函数类-结构体的封装"><a href="#对函数类-结构体的封装" class="headerlink" title="对函数类/结构体的封装"></a>对函数类/结构体的封装</h2><p>定义一个除法的结构体或者类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_div</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a / b; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其封装为一个function对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_div = my_div();</span><br></pre></td></tr></table></figure><p>同样的，调用形式和上面的<code>f_add</code>一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_div(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 执行完result结果为3</span></span><br></pre></td></tr></table></figure><h2 id="对Lambda表达式的封装"><a href="#对Lambda表达式的封装" class="headerlink" title="对Lambda表达式的封装"></a>对Lambda表达式的封装</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。</p><p>Lambda表达式的完整声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p> 各项具体含义如下 </p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了返回值类型，编译器可以自动推断。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了参数列表，类似普通函数中的无参函数。</span></span><br><span class="line">[capture <span class="built_in">list</span>] &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>让我们来看个例子，现在假设我们有一个无序的<code>vector</code>变量，我们想用C++标准库中的<code>sort</code>函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>sort</code>函数，旧式的做法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(), cmp);<span class="comment">// myvec是一个int类型的无序变量</span></span><br></pre></td></tr></table></figure><p>现在可以方便地利用Lambda表达式来简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span> &#123;<span class="keyword">return</span> a &lt; b;&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[x, y…]</td><td>默认以值的形式捕获指定的多个外部变量（用逗号分隔）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><p>如果我们需要修改捕获变量，这时需要利用<code>mutable</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; ++a; &#125;; <span class="comment">// 执行完后a=101</span></span><br></pre></td></tr></table></figure><h3 id="封装Lambda表达式"><a href="#封装Lambda表达式" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h3><p>现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_mul = [](<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用<code>std::function</code>实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculator</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面已经定义的<code>f_add</code>对象作为参数传入<code>calculator()</code>函数中，在内部进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = calculator(<span class="number">4</span>, <span class="number">5</span>, f_add);</span><br></pre></td></tr></table></figure><p>这样我们就实现了函数的回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的例子，我们学会了如何使用标准库中的<code>std::function</code>模板类对函数对象进行封装，从而可以统一成一种形式的调用，在最后我们还学习了如何将<code>std::function</code>类作为函数的参数，来实现回调函数的功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于标准库中的&lt;code&gt;std::function&lt;/code&gt;类模板，在&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/function&quot;&gt;cppreference&lt;/a&gt;官方给出的解释是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class template &lt;code&gt;std::function&lt;/code&gt; is a general-purpose polymorphic function wrapper. Instances of &lt;code&gt;std::function&lt;/code&gt; can store, copy, and invoke any &lt;code&gt;CopyConstructible&lt;/code&gt; &lt;code&gt;Callable&lt;/code&gt; target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="std::function" scheme="http://example.com/tags/std-function/"/>
    
    <category term="lambda表达式" scheme="http://example.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
