<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chi&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-29T13:41:19.205Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨琦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的std::function用法总结</title>
    <link href="http://example.com/2021/04/28/cpp_std_function/"/>
    <id>http://example.com/2021/04/28/cpp_std_function/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-04-29T13:41:19.205Z</updated>
    
    <content type="html"><![CDATA[<p>关于标准库中的<code>std::function</code>类模板，在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>官方给出的解释是：</p><blockquote><p>Class template <code>std::function</code> is a general-purpose polymorphic function wrapper. Instances of <code>std::function</code> can store, copy, and invoke any <code>CopyConstructible</code> <code>Callable</code> target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.</p></blockquote><a id="more"></a><p>翻译成中文的意思是：</p><p>类模板<code>std::function</code>是一种通用的多态函数封装，<code>std::function</code>的实例可以对任何<code>CopyConstructible Callable</code><strong>目标</strong>进行存储、复制和调用操作，这些<strong>目标</strong>可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。<code>std::function</code>对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。</p><p>比较通俗的理解就是，通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的<code>std::function</code>对象，让我们不需要再纠结那么多的可调用实体。</p><h2 id="对函数的封装"><a href="#对函数的封装" class="headerlink" title="对函数的封装"></a>对函数的封装</h2><p>我们现在有一个实现加法的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将其封装为一个function类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = add;</span><br></pre></td></tr></table></figure><p>现在就我们可以调用<code>f_add</code>实体对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_add(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 结果将返回9</span></span><br></pre></td></tr></table></figure><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用<code>std::function</code>实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculator</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面已经定义的<code>f_add</code>对象作为参数传入<code>calculator()</code>函数中，在内部进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = calculator(<span class="number">4</span>, <span class="number">5</span>, f_add);</span><br></pre></td></tr></table></figure><p>这样我们就实现了函数的回调。</p><h2 id="封装Lambda表达式"><a href="#封装Lambda表达式" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h2><p>我们可以直接封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = []() &#123; add(<span class="number">42</span>, <span class="number">2</span>); &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于标准库中的&lt;code&gt;std::function&lt;/code&gt;类模板，在&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/function&quot;&gt;cppreference&lt;/a&gt;官方给出的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class template &lt;code&gt;std::function&lt;/code&gt; is a general-purpose polymorphic function wrapper. Instances of &lt;code&gt;std::function&lt;/code&gt; can store, copy, and invoke any &lt;code&gt;CopyConstructible&lt;/code&gt; &lt;code&gt;Callable&lt;/code&gt; target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式（C++语言）</title>
    <link href="http://example.com/2021/03/03/design_pattern_cpp/"/>
    <id>http://example.com/2021/03/03/design_pattern_cpp/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2021-03-10T02:04:01.881Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。<a id="more"></a></p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>想象一下这样的场景：客户要求用C++面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，并且得到结果。</p><h2 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h2><p>首先考虑一个计算器，展示给用户看到的界面，只有数字和一些运算符，用户操作通常是不同数字和操作符的组合，将其称之为界面逻辑；在程序进行具体计算的过程中，分为多种情况考虑，实现运算的过程称之为业务逻辑。程序设计的原则之一是将业务逻辑与界面逻辑分开，让他们之间的耦合度降低。</p><h2 id="让程序松耦合"><a href="#让程序松耦合" class="headerlink" title="让程序松耦合"></a>让程序松耦合</h2><p>设计程序要尽量做到松耦合，在本案例中应该把加减乘除等运算分离，修改其中一个不会影响到其他的操作符，增加运算算法也不会影响其他代码。首先，是设计一个运算类，它有两个<code>Number</code>属性，主要用于计算前后数，然后有一个虚方法<code>get_result()</code>，用于获得结果。具体的加减乘除写出运算类的子类，然后继承它，重写<code>get_result()</code>方法，这样的话，如果修改任意一个算法，就不需要提供其他算法的代码。</p><p>运算类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Operation() :numA_(<span class="number">0</span>), numB_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Operation() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_numA</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numA_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_numB</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numB_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numA</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; numA_ = a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numB</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123; numB_ = b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> numA_;</span><br><span class="line"><span class="keyword">double</span> numB_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationAdd() &#123;&#125;</span><br><span class="line">~OperationAdd() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() + get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>减法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationSub() &#123;&#125;</span><br><span class="line">~OperationSub() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() - get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>乘法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationMul() &#123;&#125;</span><br><span class="line">~OperationMul() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> get_numA() * get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除法操作符类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> :</span><span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">OperationDiv() &#123;&#125;</span><br><span class="line">~OperationDiv() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get_numB() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;Error, divisor cannot be 0.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> get_numA() / get_numB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>现在的问题是如何去实例化对象，考虑用一个单独的类来做这个创造实例的过程，将这个类称之为工厂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation* <span class="title">CreatOperation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; op)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationAdd;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationSub;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationMul;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationDiv;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;Not find operation!&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式实现了计算器的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">OperationFactory factory;</span><br><span class="line">Operation* op = factory.CreatOperation(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">op-&gt;set_numA(<span class="number">5</span>);</span><br><span class="line">op-&gt;set_numB(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">double</span> res = op-&gt;get_result();</span><br><span class="line"><span class="keyword">delete</span> op;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;res is &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p> <strong>工厂方法模式</strong>是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 <code>卡车</code>的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。</p><p> 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 <code>卡车</code>类相关。 在程序中添加 <code>轮船</code>类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 </p><p>最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p> 工厂方法模式建议使用特殊的<em>工厂</em>方法代替对于对象构造函数的直接调用 （即使用 <code>new</code>运算符）。 不用担心， 对象仍将通过 <code>new</code>运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p><p> <img src="https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution1.png" alt="创建者类结构"> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。</summary>
    
    
    
    <category term="编程技巧" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>电磁场数值计算中常用到的一些常数</title>
    <link href="http://example.com/2021/02/18/constants_in_EM/"/>
    <id>http://example.com/2021/02/18/constants_in_EM/</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2021-02-18T11:14:59.594Z</updated>
    
    <content type="html"><![CDATA[<p>在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PI &#x3D; 3.141592653589793;</span><br><span class="line">EPS_0 &#x3D; 8.8541878128e-12;</span><br><span class="line">MU_0 &#x3D; 1.25663706212e-6;</span><br><span class="line">C_0 &#x3D; 299792458;</span><br><span class="line">Z_0 &#x3D; 376.730313668;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为&lt;/p&gt;</summary>
    
    
    
    <category term="数值计算" scheme="http://example.com/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="电磁场" scheme="http://example.com/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    
    <category term="常数" scheme="http://example.com/tags/%E5%B8%B8%E6%95%B0/"/>
    
  </entry>
  
</feed>
