{"pages":[{"title":"我的简历","text":"杨琦 18710892270 · yanchio@163.com · imyangqi 基本情况 性别男，贵州天柱人，1995年1月出生，西安电子科技大学电子工程学院电磁场与微波技术专业2017级硕士研究生。 教育经历 2017.08~2020.07，西安电子科技大学，硕士，专业：电磁场与微波技术荣誉：一等奖学金（2017年、2019年），优秀研究生（2018年，2020年） 2013.08~2017.07，西安电子科技大学，学士，专业：电子信息工程荣誉：国家励志奖学金（2016年） 发表论文 [1] Q. Yang, Y. Shi, Z. G. Ban and S. C. Zhu, “A Nodal Discontinuous Galerkin Time-Domain Method Based on Wave Equation,” in IEEE Antennas and Wireless Propagation Letters, vol. 19, no. 7, pp. 1083-1087, July 2020, doi: 10.1109/LAWP.2020.2988916. [2] Q. Yang and Y. Shi, “Application of Nodal Discontinuous Galerkin Time Domain Method Based on Wave Equation in Electromagnetic Simulations,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), Xiamen, China, 2019, pp. 1075-1081, doi: 10.1109/PIERS-Fall48861.2019.9021891.Best Student Paper Award(Honorable Mention, PIERS2019 in Xiamen) [3] Z. G. Ban, Y. Shi, Q. Yang, P. Wang, S. C. Zhu and L. Li, “GPU-Accelerated Hybrid Discontinuous Galerkin Time Domain Algorithm With Universal Matrices and Local Time Stepping Method,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 6, pp. 4738-4752, June 2020, doi: 10.1109/TAP.2020.2972404. 竞赛经历 “华为杯”第15届中国研究生数学建模竞赛，一等奖（国家级），2018年10月，队长，负责建模与编程 为解决海洋潮汐潮流运动分析困难问题，构建了基于卫星高度计海面高度异常资料的潮汐调和分析模型，运用最小二乘和多项式拟合的方法分析了南海海域各主要分潮的调和常数，模型计算结果和验潮站实际测量数据吻合良好，可以为区域海洋潮汐的数值模拟工作提供重要的资料数据。 “美国大学生数学建模竞赛(ICM)，一等奖（国际级），2016年4月，队员，负责建模与编程 为解决当今世界上部分地区水资源短缺问题，运用模糊层次综合评价的理论建立了相应的地区水资源评价模型，然后预测了模型中的每个因子数据。根据影响因素与供需比的关系，预测了印度未来15年的用水情况，最后给出了政府干预的一些建议。 项目经历 研究课题：基于节点型间断伽辽金时域方法在电磁仿真中的应用，2018年10月~2020年2月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)该项目要求建立基于Maxwell方程和波动方程的不连续伽辽金时域算法的高性能电磁仿真平台。首先编程实现求解器的核心算法，内容包括Mesh文件处理、参数设置、模型求解、结果输出等基本功能，然后再通过OpenMP和MPI等技术将核心算法改写成并行架构以实现高性能的求解能力。本人主要负责的工作有：1、推导基于Maxwell方程的DGTD算法的主要核心公式和编程实现；2、推导在该框架下的波端口边界公式和编程实现；3、推导基于波动方程的节点型DGTD算法的核心公式并编程实现。 研究课题：基于波动方程的间断时域伽辽金方法的波端口建模，2017年8月~2018年9月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)传统实现波端口（Waveport）的方法是在端口截面使用总场/散射场的形式施加一个电流源或磁流源，然后在后端使用PML边界条件吸收电磁波，这种方法通常现需要额外的计算区域用于PML的建模。该项目的主要目的是通过使用一种精确的波端口边界吸收条件，将波端口面上的使用模式函数展开，再通过一种模式匹配的策略，使其不需要建模额外的计算区域也能精确得吸收反射的电磁波，从而能够精确计算S参数。 技能清单 ●●●○○ C++/Matlab ●●●●○ 计算电磁学中的间断伽辽金时域方法 ●●●●○ 电磁场原理/天线原理/微波网络原理 ●●●●○ Latex/OriginLab/HFSS/CST/FEKO","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"photos","text":"","link":"/photos/index.html"}],"posts":[{"title":"电磁场数值计算中常用到的一些常数","text":"在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为 12345PI = 3.141592653589793;EPS_0 = 8.8541878128e-12;MU_0 = 1.25663706212e-6;C_0 = 299792458;Z_0 = 376.730313668;","link":"/2021/02/18/constants_in_EM/"},{"title":"C++中的std::function用法总结","text":"关于标准库中的std::function类模板，在cppreference官方给出的解释是： Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any CopyConstructible Callable target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. 翻译成中文的意思是： 类模板std::function是一种通用的多态函数封装，std::function的实例可以对任何CopyConstructible Callable目标进行存储、复制和调用操作，这些目标可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。std::function对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。 比较通俗的理解就是，通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的std::function对象，让我们不需要再纠结那么多的可调用实体。 对函数的封装我们现在有一个实现加法的函数 1234double add(double a, double b){ return a + b;} 我们可以将其封装为一个function类 1std::function&lt;double(double, double)&gt; f_add = add; 现在就我们可以调用f_add实体对象 1auto result = f_add(4,5); // 结果将返回9 将函数作为参数很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用std::function实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。 1234double calculator(double a, double b, std::function&lt;double(double, double)&gt; fn){ return fn(a, b);} 我们将上面已经定义的f_add对象作为参数传入calculator()函数中，在内部进行调用 1auto res = calculator(4, 5, f_add); 这样我们就实现了函数的回调。 封装Lambda表达式我们可以直接封装 1std::function&lt;double(double, double)&gt; f_add = []() { add(42, 2); };","link":"/2021/04/28/cpp_std_function/"},{"title":"常用设计模式（C++语言）","text":"我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。 简单工厂模式想象一下这样的场景：客户要求用C++面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，并且得到结果。 业务的封装首先考虑一个计算器，展示给用户看到的界面，只有数字和一些运算符，用户操作通常是不同数字和操作符的组合，将其称之为界面逻辑；在程序进行具体计算的过程中，分为多种情况考虑，实现运算的过程称之为业务逻辑。程序设计的原则之一是将业务逻辑与界面逻辑分开，让他们之间的耦合度降低。 让程序松耦合设计程序要尽量做到松耦合，在本案例中应该把加减乘除等运算分离，修改其中一个不会影响到其他的操作符，增加运算算法也不会影响其他代码。首先，是设计一个运算类，它有两个Number属性，主要用于计算前后数，然后有一个虚方法get_result()，用于获得结果。具体的加减乘除写出运算类的子类，然后继承它，重写get_result()方法，这样的话，如果修改任意一个算法，就不需要提供其他算法的代码。 运算类： 12345678910111213141516class Operation{public: Operation() :numA_(0), numB_(0) {} virtual ~Operation() {} double get_numA()const { return numA_; } double get_numB()const { return numB_; } void set_numA(double a) { numA_ = a; } void set_numB(double b) { numB_ = b; } virtual double get_result() const { return 0; }private: double numA_; double numB_;}; 加法操作符类： 1234567891011class OperationAdd :public Operation{public: OperationAdd() {} ~OperationAdd() {} double get_result() const override { return get_numA() + get_numB(); }}; 减法操作符类： 12345678910class OperationSub :public Operation{public: OperationSub() {} ~OperationSub() {} double get_result() const override { return get_numA() - get_numB(); }}; 乘法操作符类： 12345678910class OperationMul :public Operation{public: OperationMul() {} ~OperationMul() {} double get_result() const override { return get_numA() * get_numB(); }}; 除法操作符类： 1234567891011121314class OperationDiv :public Operation{public: OperationDiv() {} ~OperationDiv() {} double get_result() const override { if (get_numB() == 0) { throw std::logic_error(&quot;Error, divisor cannot be 0.&quot;); } return get_numA() / get_numB(); }}; 简单工厂模式现在的问题是如何去实例化对象，考虑用一个单独的类来做这个创造实例的过程，将这个类称之为工厂。 12345678910111213141516171819202122232425class OperationFactory{public: Operation* CreatOperation(const char&amp; op) const { switch (op) { case '+': return new OperationAdd; break; case '-': return new OperationSub; break; case '*': return new OperationMul; break; case '/': return new OperationDiv; break; default: throw std::logic_error(&quot;Not find operation!&quot;); break; } }}; 现在只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式实现了计算器的结果。 12345678910int main() { OperationFactory factory; Operation* op = factory.CreatOperation('+'); op-&gt;set_numA(5); op-&gt;set_numB(6); double res = op-&gt;get_result(); delete op; std::cout &lt;&lt; &quot;res is &quot; &lt;&lt; res &lt;&lt; std::endl; return 0;} 工厂方法模式意图 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 问题假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 解决方案 工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。","link":"/2021/03/03/design_pattern_cpp/"}],"tags":[{"name":"电磁场","slug":"电磁场","link":"/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"},{"name":"常数","slug":"常数","link":"/tags/%E5%B8%B8%E6%95%B0/"},{"name":"c++标准库","slug":"c-标准库","link":"/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"数值计算","slug":"数值计算","link":"/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"编程技巧","slug":"编程技巧","link":"/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}]}