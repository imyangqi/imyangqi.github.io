{"pages":[{"title":"","text":"关于光And God Said $$ \\begin{aligned} \\nabla \\times \\mathbf{H}&=\\mathbf{J}_{\\mathrm{free}}+\\frac{\\partial \\mathbf{D}}{\\partial t} \\\\ \\nabla \\times \\mathbf{E}&=-\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\ \\nabla \\cdot \\mathbf{B}&=0 \\\\ \\nabla \\cdot \\mathbf{D}&=\\rho _{\\mathrm{free}} \\end{aligned} $$ and then there was light. 关于我一枚电磁算法工程师，主要研究方向：DGTD/FDTD。 我相信，通过我们不断的努力，国产工业软件会越来越好。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"我的相册","text":"我的大朋友 我的小朋友","link":"/photos/index.html"},{"title":"我的简历","text":"杨琦 yanchio@163.com · imyangqi 教育经历 2017.08~2020.07，西安电子科技大学，硕士，专业：电磁场与微波技术荣誉：一等奖学金[2017/2019年]，优秀研究生[2018/2020年]，优秀学位论文提名奖[2020年] 2013.08~2017.07，西安电子科技大学，学士，专业：电子信息工程荣誉：国家励志奖学金[2016年] 竞赛经历 “华为杯”第15届中国研究生数学建模竞赛，一等奖（国家级），2018年10月，队长，负责建模与编程 为解决海洋潮汐潮流运动分析困难问题，构建了基于卫星高度计海面高度异常资料的潮汐调和分析模型，运用最小二乘和多项式拟合的方法分析了南海海域各主要分潮的调和常数，模型计算结果和验潮站实际测量数据吻合良好，可以为区域海洋潮汐的数值模拟工作提供重要的资料数据。 “美国大学生数学建模竞赛(ICM)，一等奖（国际级），2016年4月，队员，负责建模与编程 为解决当今世界上部分地区水资源短缺问题，运用模糊层次综合评价的理论建立了相应的地区水资源评价模型，然后预测了模型中的每个因子数据。根据影响因素与供需比的关系，预测了印度未来15年的用水情况，最后给出了政府干预的一些建议。 项目经历 研究课题：基于节点型间断伽辽金时域方法在电磁仿真中的应用，2018年10月~2020年2月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)该项目要求建立基于Maxwell方程和波动方程的不连续伽辽金时域算法的高性能电磁仿真平台。首先编程实现求解器的核心算法，内容包括Mesh文件处理、参数设置、模型求解、结果输出等基本功能，然后再通过OpenMP和MPI等技术将核心算法改写成并行架构以实现高性能的求解能力。本人主要负责的工作有：1、推导基于Maxwell方程的DGTD算法的主要核心公式和编程实现；2、推导在该框架下的波端口边界公式和编程实现；3、推导基于波动方程的节点型DGTD算法的核心公式并编程实现。 研究课题：基于波动方程的间断时域伽辽金方法的波端口建模，2017年8月~2018年9月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)传统实现波端口（Waveport）的方法是在端口截面使用总场/散射场的形式施加一个电流源或磁流源，然后在后端使用PML边界条件吸收电磁波，这种方法通常现需要额外的计算区域用于PML的建模。该项目的主要目的是通过使用一种精确的波端口边界吸收条件，将波端口面上的使用模式函数展开，再通过一种模式匹配的策略，使其不需要建模额外的计算区域也能精确得吸收反射的电磁波，从而能够精确计算S参数。 发表论文 [1] Q. Yang, Y. Shi, Z. G. Ban and S. C. Zhu, “A Nodal Discontinuous Galerkin Time-Domain Method Based on Wave Equation,” in IEEE Antennas and Wireless Propagation Letters, vol. 19, no. 7, pp. 1083-1087, July 2020, doi: 10.1109/LAWP.2020.2988916. [2] Q. Yang and Y. Shi, “Application of Nodal Discontinuous Galerkin Time Domain Method Based on Wave Equation in Electromagnetic Simulations,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), Xiamen, China, 2019, pp. 1075-1081, doi: 10.1109/PIERS-Fall48861.2019.9021891.Best Student Paper Award(Honorable Mention, PIERS2019 in Xiamen) [3]P. Wang, Y. Shi, Z. G. Ban, S. C. Zhu, Q. Yang and L. Li, “Penalty Factor Threshold and Time Step Bound Estimations for Discontinuous Galerkin Time-Domain Method Based on Helmholtz Equation,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 11, pp. 7494-7506, Nov. 2020, doi: 10.1109/TAP.2020.2998585. [4] Z. G. Ban, Y. Shi, Q. Yang, P. Wang, S. C. Zhu and L. Li, “GPU-Accelerated Hybrid Discontinuous Galerkin Time Domain Algorithm With Universal Matrices and Local Time Stepping Method,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 6, pp. 4738-4752, June 2020, doi: 10.1109/TAP.2020.2972404. [5] Y. Shi, P. Wang, Z. G. Ban, Q. Yang and S. C. Zhu, “Application of Hybridized Discontinuous Galerkin Time Domain Method into the Solution of Multiscale Electromagnetic Problems,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), 2019, pp. 2325-2329, doi: 10.1109/PIERS-Fall48861.2019.9021911. 技能清单 C++/Python/Matlab [●●●○○] 计算电磁学中的间断伽辽金时域方法 [●●●●○] 电磁场原理/天线原理/微波网络原理 [●●●●○] Latex/OriginLab/HFSS/CST/FEKO [●●●●○]","link":"/resume/index.html"}],"posts":[{"title":"电磁场数值计算中常用到的一些常数","text":"在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为 12345PI = 3.141592653589793;EPS_0 = 8.8541878128e-12;MU_0 = 1.25663706212e-6;C_0 = 299792458;Z_0 = 376.730313668;","link":"/2021/02/18/constants_in_EM/"},{"title":"C++中的std::function&#x2F;Lambda表达式&#x2F;std::bind用法总结","text":"关于标准库中的std::function类模板，在cppreference官方给出的解释是 Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any CopyConstructible Callable target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. 翻译成中文的意思是：类模板std::function是一种通用的多态函数封装，std::function的实例可以对任何CopyConstructible Callable目标进行存储、复制和调用操作，这些目标可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。std::function对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。 比较通俗的理解就是，通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的std::function对象，让我们不需要再纠结那么多的可调用实体。 直接对函数的封装现在定义一个实现加法的函数 1234double add(double a, double b){ return a + b;} 将其封装为一个function类 1std::function&lt;double(double, double)&gt; f_add = add; 现在就我们可以调用f_add实体对象 1auto result = f_add(4,5); // 结果将返回9 对函数类/结构体的封装我们定义一个除法的结构体或者类 1234567struct my_div{ double operator()(double a, double b) { return a / b; }}; 将其封装为一个function对象 1std::function&lt;double(double, double)&gt; f_div = my_div(); 同样的，调用形式和上面的f_add一样 1auto result = f_div(6, 2); // 执行完result结果为3 将函数作为参数很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用std::function实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。 1234double calculator(double a, double b, std::function&lt;double(double, double)&gt; fn){ return fn(a, b);} 我们将上面已经定义的f_add对象作为参数传入calculator()函数中，在内部进行调用 1auto res = calculator(4, 5, f_add); 这样我们就实现了函数的回调。 封装Lambda表达式Lambda表达式Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。 Lambda表达式的完整声明为： 1[capture list] (params list) mutable exception-&gt; return type { function body } 各项具体含义如下 capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下 123456// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。[capture list] (params list) -&gt; return type {function body}// 省略了返回值类型，编译器可以自动推断。[capture list] (params list) {function body}// 省略了参数列表，类似普通函数中的无参函数。[capture list] {function body} 让我们来看个例子，现在假设我们有一个无序的vector变量，我们想用C++标准库中的sort函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数 1234bool cmp(int a, int b){ return a &lt; b;} 调用sort函数，旧式的做法如下 1sort(myvec.begin(), myvec.end(), cmp);// myvec是一个int类型的无序变量 现在可以方便地利用Lambda表达式来简化代码 1sort(myvec.begin(), myvec.end(),[](int a, int b)-&gt;bool {return a &lt; b;}); 值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种： 捕获形式 说明 [] 不捕获任何外部变量 [x, y…] 默认以值的形式捕获指定的多个外部变量（用逗号分隔） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 如果我们需要修改捕获变量，这时需要利用mutable关键字 12int a = 100;auto f = [a]()mutable { cout &lt;&lt; ++a; }; // 执行完后a=101 封装Lambda表达式现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为 1std::function&lt;double(double, double)&gt; f_mul = [](double x, double y) { return x * y; }; std::bind函数定义： The function template bind generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with some of its arguments bound to args. 翻译： 函数模板bind会对函数模板f生成一个前向调用封装，调用此封装相当于调用f，其某些参数绑定到args。 解释： 函数绑定bind函数用于把某种形式的参数列表与已知的函数进行绑定，形成新的函数。 这种更改已有函数调用模式的做法，就叫函数绑定。需要指出：bind就是函数适配器。 问题：什么是适配器？适配器是一种机制，把已有的东西改吧改吧、限制限制，从而让它适应新的逻辑。需要指出，容器、迭代器和函数都有适配器。bind就是一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。 bind使用的一般形式： 1auto newfun = bind(fun, arg_list); 其中fun是一函数，arg_list是用逗号隔开的参数列表。调用newfun()，newfun会调用fun(arg_list); bind的常见用法一 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; using namespace std::placeholders; int main() { auto fun = [](int *array, int n, int num){ for (int i = 0; i &lt; n; i++) { if (array[i] &gt; num) cout &lt;&lt; array[i] &lt;&lt; ends; } cout &lt;&lt; endl; }; int array[] = { 1, 3, 5, 7, 9 }; //_1，_2 是占位符 auto fun1 = bind(fun, _1, _2, 5); //等价于调用fun(array, sizeof(array) / sizeof(*array), 5); fun1(array, sizeof(array) / sizeof(*array)); cin.get(); return 0; } 在本例中，fun()的调用需要传递三个参数，而用bind()进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是bind最常见的用法。 2._1，_2是占位符，定义于命名空间placeholders中。_1是newfun的第一个参数，_2是newfun的第二个参数，以此类推。 bind的常见用法二 bind的另一个常见的用法是更改参数的调用顺序。如 12int fun(int a, int b);auto newfun = bind(fun, _2, _1); 调用newfun(1, 2);相当于调用fun(2, 1);","link":"/2021/04/28/cpp_std_function/"},{"title":"常用设计模式（C++语言）","text":"我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。 简单工厂模式想象一下这样的场景：客户要求用C++面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，并且得到结果。 业务的封装首先考虑一个计算器，展示给用户看到的界面，只有数字和一些运算符，用户操作通常是不同数字和操作符的组合，将其称之为界面逻辑；在程序进行具体计算的过程中，分为多种情况考虑，实现运算的过程称之为业务逻辑。程序设计的原则之一是将业务逻辑与界面逻辑分开，让他们之间的耦合度降低。 让程序松耦合设计程序要尽量做到松耦合，在本案例中应该把加减乘除等运算分离，修改其中一个不会影响到其他的操作符，增加运算算法也不会影响其他代码。首先，是设计一个运算类，它有两个Number属性，主要用于计算前后数，然后有一个虚方法get_result()，用于获得结果。具体的加减乘除写出运算类的子类，然后继承它，重写get_result()方法，这样的话，如果修改任意一个算法，就不需要提供其他算法的代码。 运算类： 12345678910111213141516class Operation{public: Operation() :numA_(0), numB_(0) {} virtual ~Operation() {} double get_numA()const { return numA_; } double get_numB()const { return numB_; } void set_numA(double a) { numA_ = a; } void set_numB(double b) { numB_ = b; } virtual double get_result() const { return 0; }private: double numA_; double numB_;}; 加法操作符类： 1234567891011class OperationAdd :public Operation{public: OperationAdd() {} ~OperationAdd() {} double get_result() const override { return get_numA() + get_numB(); }}; 减法操作符类： 12345678910class OperationSub :public Operation{public: OperationSub() {} ~OperationSub() {} double get_result() const override { return get_numA() - get_numB(); }}; 乘法操作符类： 12345678910class OperationMul :public Operation{public: OperationMul() {} ~OperationMul() {} double get_result() const override { return get_numA() * get_numB(); }}; 除法操作符类： 1234567891011121314class OperationDiv :public Operation{public: OperationDiv() {} ~OperationDiv() {} double get_result() const override { if (get_numB() == 0) { throw std::logic_error(&quot;Error, divisor cannot be 0.&quot;); } return get_numA() / get_numB(); }}; 简单工厂模式现在的问题是如何去实例化对象，考虑用一个单独的类来做这个创造实例的过程，将这个类称之为工厂。 12345678910111213141516171819202122232425class OperationFactory{public: Operation* CreatOperation(const char&amp; op) const { switch (op) { case '+': return new OperationAdd; break; case '-': return new OperationSub; break; case '*': return new OperationMul; break; case '/': return new OperationDiv; break; default: throw std::logic_error(&quot;Not find operation!&quot;); break; } }}; 现在只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式实现了计算器的结果。 12345678910int main() { OperationFactory factory; Operation* op = factory.CreatOperation('+'); op-&gt;set_numA(5); op-&gt;set_numB(6); double res = op-&gt;get_result(); delete op; std::cout &lt;&lt; &quot;res is &quot; &lt;&lt; res &lt;&lt; std::endl; return 0;} 工厂方法模式意图 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 问题假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 解决方案 工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。","link":"/2021/03/03/design_pattern_cpp/"}],"tags":[{"name":"电磁场","slug":"电磁场","link":"/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"},{"name":"常数","slug":"常数","link":"/tags/%E5%B8%B8%E6%95%B0/"},{"name":"c++标准库","slug":"c-标准库","link":"/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"数值计算","slug":"数值计算","link":"/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"编程技巧","slug":"编程技巧","link":"/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}]}