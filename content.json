{"pages":[{"title":"","text":"关于光上帝说，要有光 $$ \\begin{aligned} \\nabla \\times \\mathbf{H}&=\\mathbf{J}_{\\mathrm{free}}+\\frac{\\partial \\mathbf{D}}{\\partial t} \\\\ \\nabla \\times \\mathbf{E}&=-\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\ \\nabla \\cdot \\mathbf{B}&=0 \\\\ \\nabla \\cdot \\mathbf{D}&=\\rho _{\\mathrm{free}} \\end{aligned} $$ 于是便有了光。这就是著名的麦克斯韦方程，光亦是一种电磁波。 关于我我是一名电磁算法工程师，任职于某国产工业软件公司。 我在努力地学习和计算机相关的知识，以及更多的电磁场专业相关的算法和应用。 希望在不久的将来，我能成为一名合格的电磁算法工程师，目前我正在朝着这个方向不断前进。 我相信，会有越来越多的年轻人加入到国产工业软件的建设当中来，让我们一起为之努力。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"我的相册","text":"[2020年7月]硕士毕业留影","link":"/photos/index.html"},{"title":"我的简历","text":"杨琦 yanchio@163.com · imyangqi 教育经历 2017.08~2020.07，西安电子科技大学，硕士，专业：电磁场与微波技术荣誉：一等奖学金[2017/2019年]，优秀研究生[2018/2020年]，优秀学位论文提名奖[2020年] 2013.08~2017.07，西安电子科技大学，学士，专业：电子信息工程荣誉：国家励志奖学金[2016年] 竞赛经历 “华为杯”第15届中国研究生数学建模竞赛，一等奖（国家级），2018年10月，队长，负责建模与编程 为解决海洋潮汐潮流运动分析困难问题，构建了基于卫星高度计海面高度异常资料的潮汐调和分析模型，运用最小二乘和多项式拟合的方法分析了南海海域各主要分潮的调和常数，模型计算结果和验潮站实际测量数据吻合良好，可以为区域海洋潮汐的数值模拟工作提供重要的资料数据。 “美国大学生数学建模竞赛(ICM)，一等奖（国际级），2016年4月，队员，负责建模与编程 为解决当今世界上部分地区水资源短缺问题，运用模糊层次综合评价的理论建立了相应的地区水资源评价模型，然后预测了模型中的每个因子数据。根据影响因素与供需比的关系，预测了印度未来15年的用水情况，最后给出了政府干预的一些建议。 项目经历 研究课题：基于节点型间断伽辽金时域方法在电磁仿真中的应用，2018年10月~2020年2月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)该项目要求建立基于Maxwell方程和波动方程的不连续伽辽金时域算法的高性能电磁仿真平台。首先编程实现求解器的核心算法，内容包括Mesh文件处理、参数设置、模型求解、结果输出等基本功能，然后再通过OpenMP和MPI等技术将核心算法改写成并行架构以实现高性能的求解能力。本人主要负责的工作有：1、推导基于Maxwell方程的DGTD算法的主要核心公式和编程实现；2、推导在该框架下的波端口边界公式和编程实现；3、推导基于波动方程的节点型DGTD算法的核心公式并编程实现。 研究课题：基于波动方程的间断时域伽辽金方法的波端口建模，2017年8月~2018年9月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)传统实现波端口（Waveport）的方法是在端口截面使用总场/散射场的形式施加一个电流源或磁流源，然后在后端使用PML边界条件吸收电磁波，这种方法通常现需要额外的计算区域用于PML的建模。该项目的主要目的是通过使用一种精确的波端口边界吸收条件，将波端口面上的使用模式函数展开，再通过一种模式匹配的策略，使其不需要建模额外的计算区域也能精确得吸收反射的电磁波，从而能够精确计算S参数。 发表论文 [1] Q. Yang, Y. Shi, Z. G. Ban and S. C. Zhu, “A Nodal Discontinuous Galerkin Time-Domain Method Based on Wave Equation,” in IEEE Antennas and Wireless Propagation Letters, vol. 19, no. 7, pp. 1083-1087, July 2020, doi: 10.1109/LAWP.2020.2988916. [2] Q. Yang and Y. Shi, “Application of Nodal Discontinuous Galerkin Time Domain Method Based on Wave Equation in Electromagnetic Simulations,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), Xiamen, China, 2019, pp. 1075-1081, doi: 10.1109/PIERS-Fall48861.2019.9021891.Best Student Paper Award(Honorable Mention, PIERS2019 in Xiamen) [3]P. Wang, Y. Shi, Z. G. Ban, S. C. Zhu, Q. Yang and L. Li, “Penalty Factor Threshold and Time Step Bound Estimations for Discontinuous Galerkin Time-Domain Method Based on Helmholtz Equation,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 11, pp. 7494-7506, Nov. 2020, doi: 10.1109/TAP.2020.2998585. [4] Z. G. Ban, Y. Shi, Q. Yang, P. Wang, S. C. Zhu and L. Li, “GPU-Accelerated Hybrid Discontinuous Galerkin Time Domain Algorithm With Universal Matrices and Local Time Stepping Method,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 6, pp. 4738-4752, June 2020, doi: 10.1109/TAP.2020.2972404. [5] Y. Shi, P. Wang, Z. G. Ban, Q. Yang and S. C. Zhu, “Application of Hybridized Discontinuous Galerkin Time Domain Method into the Solution of Multiscale Electromagnetic Problems,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), 2019, pp. 2325-2329, doi: 10.1109/PIERS-Fall48861.2019.9021911. 技能清单 C++/Python/Matlab [●●●○○] 计算电磁学中的间断伽辽金时域方法 [●●●●○] 电磁场原理/天线原理/微波网络原理 [●●●●○] Latex/OriginLab/HFSS/CST/FEKO [●●●●○]","link":"/resume/index.html"}],"posts":[{"title":"C++中的std::bind用法总结","text":"前言std::bind包含在标准库头文件#include&lt;functional&gt;中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。 使用格式 std::bind使用的一般形式： 1auto new_fun = bind(fun, arg_list); 其中fun是一个函数，arg_list是用逗号隔开的参数列表。调用new_fun()相当于调用fun(arg_list)。 常见用法用法一：改变参数的个数头文件： 1234#include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; using namespace std::placeholders; 现在定义一个函数，接收一个数组array，数组长度n和某个数num，它将实现打印数组中大于num的功能 12345678auto fun = [](int *array, int n, int num){ for (int i = 0; i &lt; n; i++) { if (array[i] &gt; num) cout &lt;&lt; array[i] &lt;&lt; ends; } cout &lt;&lt; endl; }; 利用std::bind函数将原来函数调用所需要的参数固定为2个，实现过程如下： 123int array[] = { 1, 3, 5, 7, 9 }; auto new_fun = bind(fun, _1, _2, 5); //_1，_2是占位符，固定num=5 new_fun(array, sizeof(array) / sizeof(*array)); // 调用只需要2个参数了 上面代码中_1，_2是占位符，定义于命名空间placeholders中，_1是nnew_fun的第一个参数，_2是new_fun的第二个参数，以此类推。在本例中，fun()的调用需要传递三个参数，而用bind()进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是bind最常见的用法。 用法二：更改参数的顺序 bind的另一个常见的用法是更改参数的调用顺序，如 12int fun(int a, int b);auto new_fun = bind(fun, _2, _1); 此时，调用new_fun(1, 2)相当于调用fun(2, 1)。","link":"/2021/04/28/cpp_std_bind/"},{"title":"C++中的std::function用法总结","text":"关于标准库中的std::function类模板，在cppreference官方给出的解释是 Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any CopyConstructible Callable target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. 中文的意思是：类模板std::function是一种通用的多态函数封装，std::function的实例可以对任何CopyConstructible Callable目标进行存储、复制和调用操作，这些目标可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。std::function对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。 比较通俗的理解就是，通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的std::function对象，让我们不需要再纠结那么多的可调用实体。 对函数的封装定义一个实现加法的函数 1234double add(double a, double b){ return a + b;} 我们可以将其封装为一个function类 1std::function&lt;double(double, double)&gt; f_add = add; 用下面的方式对f_add实体对象进行调用 1auto result = f_add(4,5); // 结果将返回9 对函数类/结构体的封装定义一个除法的结构体或者类 1234567struct my_div{ double operator()(double a, double b) { return a / b; }}; 将其封装为一个function对象 1std::function&lt;double(double, double)&gt; f_div = my_div(); 同样的，调用形式和上面的f_add一样 1auto result = f_div(6, 2); // 执行完result结果为3 对Lambda表达式的封装Lambda表达式Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。 Lambda表达式的完整声明为： 1[capture list] (params list) mutable exception-&gt; return type { function body } 各项具体含义如下 capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下 123456// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。[capture list] (params list) -&gt; return type {function body}// 省略了返回值类型，编译器可以自动推断。[capture list] (params list) {function body}// 省略了参数列表，类似普通函数中的无参函数。[capture list] {function body} 让我们来看个例子，现在假设我们有一个无序的vector变量，我们想用C++标准库中的sort函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数 1234bool cmp(int a, int b){ return a &lt; b;} 调用sort函数，旧式的做法如下 1sort(myvec.begin(), myvec.end(), cmp);// myvec是一个int类型的无序变量 现在可以方便地利用Lambda表达式来简化代码 1sort(myvec.begin(), myvec.end(),[](int a, int b)-&gt;bool {return a &lt; b;}); 值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种： 捕获形式 说明 [] 不捕获任何外部变量 [x, y…] 默认以值的形式捕获指定的多个外部变量（用逗号分隔） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 如果我们需要修改捕获变量，这时需要利用mutable关键字 12int a = 100;auto f = [a]()mutable { cout &lt;&lt; ++a; }; // 执行完后a=101 封装Lambda表达式现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为 1std::function&lt;double(double, double)&gt; f_mul = [](double x, double y) { return x * y; }; 将函数作为参数很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用std::function实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。 1234double calculator(double a, double b, std::function&lt;double(double, double)&gt; fn){ return fn(a, b);} 我们将上面已经定义的f_add对象作为参数传入calculator()函数中，在内部进行调用 1auto res = calculator(4, 5, f_add); 这样我们就实现了函数的回调。 总结通过以上的例子，我们学会了如何使用标准库中的std::function模板类对函数对象进行封装，从而可以统一成一种形式的调用，在最后我们还学习了如何将std::function类作为函数的参数，来实现回调函数的功能。","link":"/2021/04/28/cpp_std_function/"}],"tags":[{"name":"std::bind","slug":"std-bind","link":"/tags/std-bind/"},{"name":"c++标准库","slug":"c-标准库","link":"/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"std::function","slug":"std-function","link":"/tags/std-function/"},{"name":"lambda表达式","slug":"lambda表达式","link":"/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]}