{"pages":[{"title":"","text":"是你们在我身上浪费的时间，让我变得如此珍贵。 关于我嗨，朋友你好呀！欢迎来到我的小角落~我的名字叫杨琦，来自太阳系第三行星，目前在该星球上是一枚初级电磁算法工程师。我的专业领域主要包括：电磁场与微波技术、FDTD/DGTD/FEM数值算法、C++/Python程序语言、软件工程学、数学物理方法。除了工作之外，我比较喜欢做的一些事情是整理房间、下厨做饭、听苏打绿的音乐、养植物、读书、看日剧、跑步。当然，现在我要开始培养自己写博客的习惯。 关于光上帝说要有光，于是就有了 $$ \\begin{aligned} \\nabla \\times \\mathbf{E}&=-\\mu \\frac{\\partial \\mathbf{H}}{\\partial t} \\\\ \\nabla \\times \\mathbf{H}&=\\varepsilon \\frac{\\partial \\mathbf{E}}{\\partial t}+\\mathbf{J} \\\\ \\nabla \\cdot \\mathbf{D}&=\\rho \\\\ \\nabla \\cdot \\mathbf{B}&=0 \\end{aligned} $$ 这就是著名的麦克斯韦方程组，光亦是一种电磁波。 关于博客其实在很早之前自己就开始搭建Hexo+Github博客，但是由于自己太懒，一年采写几篇博客，后来觉得没有用就被我删除了。工作之后，开始需要学习很多知识，有必要及时整理和输出，遂再次创建了本博客，主要用于记录日常学习和写一些专业性技术文章。关于主题风格，我觉得博客最重要的部分是内容，其次是阅读体验。就内容方面，我会努力让每一篇文章让读者看上去都是完整的和易于理解的；在阅读体验方面，我在文章布局中间删除了大量博客原主题的功能，例如留言板、版权栏、个人简介等，只留下了正文和目录，尽量营造一个舒适的阅读环境。如果关于文章你有什么想和我交流的，我相信你一定不会介意给我发送一封正式的邮件，我收到邮件后也会认真地对待，第一时间回复。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"常用设计模式（C++语言）","text":"我们在写一个程序之前，就要考虑到程序的可维护性、可复用性、可扩展性，还有灵活性。面向对象的分析设计编程思想，可以通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，并且易于复用。 简单工厂模式想象一下这样的场景：客户要求用C++面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，并且得到结果。 业务的封装首先考虑一个计算器，展示给用户看到的界面，只有数字和一些运算符，用户操作通常是不同数字和操作符的组合，将其称之为界面逻辑；在程序进行具体计算的过程中，分为多种情况考虑，实现运算的过程称之为业务逻辑。程序设计的原则之一是将业务逻辑与界面逻辑分开，让他们之间的耦合度降低。 让程序松耦合设计程序要尽量做到松耦合，在本案例中应该把加减乘除等运算分离，修改其中一个不会影响到其他的操作符，增加运算算法也不会影响其他代码。首先，是设计一个运算类，它有两个Number属性，主要用于计算前后数，然后有一个虚方法get_result()，用于获得结果。具体的加减乘除写出运算类的子类，然后继承它，重写get_result()方法，这样的话，如果修改任意一个算法，就不需要提供其他算法的代码。 运算类： 12345678910111213141516class Operation{public: Operation() :numA_(0), numB_(0) {} virtual ~Operation() {} double get_numA()const { return numA_; } double get_numB()const { return numB_; } void set_numA(double a) { numA_ = a; } void set_numB(double b) { numB_ = b; } virtual double get_result() const { return 0; }private: double numA_; double numB_;}; 加法操作符类： 1234567891011class OperationAdd :public Operation{public: OperationAdd() {} ~OperationAdd() {} double get_result() const override { return get_numA() + get_numB(); }}; 减法操作符类： 12345678910class OperationSub :public Operation{public: OperationSub() {} ~OperationSub() {} double get_result() const override { return get_numA() - get_numB(); }}; 乘法操作符类： 12345678910class OperationMul :public Operation{public: OperationMul() {} ~OperationMul() {} double get_result() const override { return get_numA() * get_numB(); }}; 除法操作符类： 1234567891011121314class OperationDiv :public Operation{public: OperationDiv() {} ~OperationDiv() {} double get_result() const override { if (get_numB() == 0) { throw std::logic_error(&quot;Error, divisor cannot be 0.&quot;); } return get_numA() / get_numB(); }}; 简单工厂模式现在的问题是如何去实例化对象，考虑用一个单独的类来做这个创造实例的过程，将这个类称之为工厂。 12345678910111213141516171819202122232425class OperationFactory{public: Operation* CreatOperation(const char&amp; op) const { switch (op) { case '+': return new OperationAdd; break; case '-': return new OperationSub; break; case '*': return new OperationMul; break; case '/': return new OperationDiv; break; default: throw std::logic_error(&quot;Not find operation!&quot;); break; } }}; 现在只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式实现了计算器的结果。 12345678910int main() { OperationFactory factory; Operation* op = factory.CreatOperation('+'); op-&gt;set_numA(5); op-&gt;set_numB(6); double res = op-&gt;get_result(); delete op; std::cout &lt;&lt; &quot;res is &quot; &lt;&lt; res &lt;&lt; std::endl; return 0;} 工厂方法模式意图 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 问题假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。 解决方案 工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。","link":"/2021/03/03/design_pattern_cpp/"},{"title":"电磁场数值计算中常用到的一些常数","text":"在电磁场数值编程中常会用到的一些常数，主要包含：圆周率(Pi)、真空中的介电常数(Vacuum permittivity)、真空中的磁导率(Vacuum permeability)、光速(Speed of light)和自由空间中的波阻抗(Impedance of free space)，具体数值为 12345PI = 3.141592653589793;EPS_0 = 8.8541878128e-12;MU_0 = 1.25663706212e-6;C_0 = 299792458;Z_0 = 376.730313668;","link":"/2021/02/18/constants_in_EM/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"电磁场","slug":"电磁场","link":"/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"},{"name":"常数","slug":"常数","link":"/tags/%E5%B8%B8%E6%95%B0/"}],"categories":[{"name":"编程技巧","slug":"编程技巧","link":"/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"},{"name":"数值计算","slug":"数值计算","link":"/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"}]}